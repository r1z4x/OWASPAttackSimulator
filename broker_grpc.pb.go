// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: broker.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	SessionService_OpenSession_FullMethodName   = "/owaspchecker.broker.SessionService/OpenSession"
	SessionService_AttachSession_FullMethodName = "/owaspchecker.broker.SessionService/AttachSession"
	SessionService_DetachSession_FullMethodName = "/owaspchecker.broker.SessionService/DetachSession"
	SessionService_CloseSession_FullMethodName  = "/owaspchecker.broker.SessionService/CloseSession"
	SessionService_GetSession_FullMethodName    = "/owaspchecker.broker.SessionService/GetSession"
	SessionService_UpdateSession_FullMethodName = "/owaspchecker.broker.SessionService/UpdateSession"
)

// SessionServiceClient is the client API for SessionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Session management service
type SessionServiceClient interface {
	OpenSession(ctx context.Context, in *OpenSessionRequest, opts ...grpc.CallOption) (*OpenSessionResponse, error)
	AttachSession(ctx context.Context, in *AttachSessionRequest, opts ...grpc.CallOption) (*AttachSessionResponse, error)
	DetachSession(ctx context.Context, in *DetachSessionRequest, opts ...grpc.CallOption) (*DetachSessionResponse, error)
	CloseSession(ctx context.Context, in *CloseSessionRequest, opts ...grpc.CallOption) (*CloseSessionResponse, error)
	GetSession(ctx context.Context, in *GetSessionRequest, opts ...grpc.CallOption) (*GetSessionResponse, error)
	UpdateSession(ctx context.Context, in *UpdateSessionRequest, opts ...grpc.CallOption) (*UpdateSessionResponse, error)
}

type sessionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSessionServiceClient(cc grpc.ClientConnInterface) SessionServiceClient {
	return &sessionServiceClient{cc}
}

func (c *sessionServiceClient) OpenSession(ctx context.Context, in *OpenSessionRequest, opts ...grpc.CallOption) (*OpenSessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OpenSessionResponse)
	err := c.cc.Invoke(ctx, SessionService_OpenSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionServiceClient) AttachSession(ctx context.Context, in *AttachSessionRequest, opts ...grpc.CallOption) (*AttachSessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AttachSessionResponse)
	err := c.cc.Invoke(ctx, SessionService_AttachSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionServiceClient) DetachSession(ctx context.Context, in *DetachSessionRequest, opts ...grpc.CallOption) (*DetachSessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DetachSessionResponse)
	err := c.cc.Invoke(ctx, SessionService_DetachSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionServiceClient) CloseSession(ctx context.Context, in *CloseSessionRequest, opts ...grpc.CallOption) (*CloseSessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CloseSessionResponse)
	err := c.cc.Invoke(ctx, SessionService_CloseSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionServiceClient) GetSession(ctx context.Context, in *GetSessionRequest, opts ...grpc.CallOption) (*GetSessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSessionResponse)
	err := c.cc.Invoke(ctx, SessionService_GetSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionServiceClient) UpdateSession(ctx context.Context, in *UpdateSessionRequest, opts ...grpc.CallOption) (*UpdateSessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateSessionResponse)
	err := c.cc.Invoke(ctx, SessionService_UpdateSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SessionServiceServer is the server API for SessionService service.
// All implementations must embed UnimplementedSessionServiceServer
// for forward compatibility.
//
// Session management service
type SessionServiceServer interface {
	OpenSession(context.Context, *OpenSessionRequest) (*OpenSessionResponse, error)
	AttachSession(context.Context, *AttachSessionRequest) (*AttachSessionResponse, error)
	DetachSession(context.Context, *DetachSessionRequest) (*DetachSessionResponse, error)
	CloseSession(context.Context, *CloseSessionRequest) (*CloseSessionResponse, error)
	GetSession(context.Context, *GetSessionRequest) (*GetSessionResponse, error)
	UpdateSession(context.Context, *UpdateSessionRequest) (*UpdateSessionResponse, error)
	mustEmbedUnimplementedSessionServiceServer()
}

// UnimplementedSessionServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSessionServiceServer struct{}

func (UnimplementedSessionServiceServer) OpenSession(context.Context, *OpenSessionRequest) (*OpenSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpenSession not implemented")
}
func (UnimplementedSessionServiceServer) AttachSession(context.Context, *AttachSessionRequest) (*AttachSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AttachSession not implemented")
}
func (UnimplementedSessionServiceServer) DetachSession(context.Context, *DetachSessionRequest) (*DetachSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DetachSession not implemented")
}
func (UnimplementedSessionServiceServer) CloseSession(context.Context, *CloseSessionRequest) (*CloseSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseSession not implemented")
}
func (UnimplementedSessionServiceServer) GetSession(context.Context, *GetSessionRequest) (*GetSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSession not implemented")
}
func (UnimplementedSessionServiceServer) UpdateSession(context.Context, *UpdateSessionRequest) (*UpdateSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSession not implemented")
}
func (UnimplementedSessionServiceServer) mustEmbedUnimplementedSessionServiceServer() {}
func (UnimplementedSessionServiceServer) testEmbeddedByValue()                        {}

// UnsafeSessionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SessionServiceServer will
// result in compilation errors.
type UnsafeSessionServiceServer interface {
	mustEmbedUnimplementedSessionServiceServer()
}

func RegisterSessionServiceServer(s grpc.ServiceRegistrar, srv SessionServiceServer) {
	// If the following call pancis, it indicates UnimplementedSessionServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SessionService_ServiceDesc, srv)
}

func _SessionService_OpenSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionServiceServer).OpenSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionService_OpenSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionServiceServer).OpenSession(ctx, req.(*OpenSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SessionService_AttachSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttachSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionServiceServer).AttachSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionService_AttachSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionServiceServer).AttachSession(ctx, req.(*AttachSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SessionService_DetachSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetachSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionServiceServer).DetachSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionService_DetachSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionServiceServer).DetachSession(ctx, req.(*DetachSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SessionService_CloseSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionServiceServer).CloseSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionService_CloseSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionServiceServer).CloseSession(ctx, req.(*CloseSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SessionService_GetSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionServiceServer).GetSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionService_GetSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionServiceServer).GetSession(ctx, req.(*GetSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SessionService_UpdateSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionServiceServer).UpdateSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SessionService_UpdateSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionServiceServer).UpdateSession(ctx, req.(*UpdateSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SessionService_ServiceDesc is the grpc.ServiceDesc for SessionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SessionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "owaspchecker.broker.SessionService",
	HandlerType: (*SessionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OpenSession",
			Handler:    _SessionService_OpenSession_Handler,
		},
		{
			MethodName: "AttachSession",
			Handler:    _SessionService_AttachSession_Handler,
		},
		{
			MethodName: "DetachSession",
			Handler:    _SessionService_DetachSession_Handler,
		},
		{
			MethodName: "CloseSession",
			Handler:    _SessionService_CloseSession_Handler,
		},
		{
			MethodName: "GetSession",
			Handler:    _SessionService_GetSession_Handler,
		},
		{
			MethodName: "UpdateSession",
			Handler:    _SessionService_UpdateSession_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "broker.proto",
}

const (
	StepService_PushStep_FullMethodName      = "/owaspchecker.broker.StepService/PushStep"
	StepService_CancelStep_FullMethodName    = "/owaspchecker.broker.StepService/CancelStep"
	StepService_GetStepStatus_FullMethodName = "/owaspchecker.broker.StepService/GetStepStatus"
	StepService_StreamEvents_FullMethodName  = "/owaspchecker.broker.StepService/StreamEvents"
)

// StepServiceClient is the client API for StepService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Step execution service
type StepServiceClient interface {
	PushStep(ctx context.Context, in *PushStepRequest, opts ...grpc.CallOption) (*PushStepResponse, error)
	CancelStep(ctx context.Context, in *CancelStepRequest, opts ...grpc.CallOption) (*CancelStepResponse, error)
	GetStepStatus(ctx context.Context, in *GetStepStatusRequest, opts ...grpc.CallOption) (*GetStepStatusResponse, error)
	StreamEvents(ctx context.Context, in *StreamEventsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Event], error)
}

type stepServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewStepServiceClient(cc grpc.ClientConnInterface) StepServiceClient {
	return &stepServiceClient{cc}
}

func (c *stepServiceClient) PushStep(ctx context.Context, in *PushStepRequest, opts ...grpc.CallOption) (*PushStepResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PushStepResponse)
	err := c.cc.Invoke(ctx, StepService_PushStep_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stepServiceClient) CancelStep(ctx context.Context, in *CancelStepRequest, opts ...grpc.CallOption) (*CancelStepResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CancelStepResponse)
	err := c.cc.Invoke(ctx, StepService_CancelStep_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stepServiceClient) GetStepStatus(ctx context.Context, in *GetStepStatusRequest, opts ...grpc.CallOption) (*GetStepStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetStepStatusResponse)
	err := c.cc.Invoke(ctx, StepService_GetStepStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stepServiceClient) StreamEvents(ctx context.Context, in *StreamEventsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Event], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &StepService_ServiceDesc.Streams[0], StepService_StreamEvents_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamEventsRequest, Event]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type StepService_StreamEventsClient = grpc.ServerStreamingClient[Event]

// StepServiceServer is the server API for StepService service.
// All implementations must embed UnimplementedStepServiceServer
// for forward compatibility.
//
// Step execution service
type StepServiceServer interface {
	PushStep(context.Context, *PushStepRequest) (*PushStepResponse, error)
	CancelStep(context.Context, *CancelStepRequest) (*CancelStepResponse, error)
	GetStepStatus(context.Context, *GetStepStatusRequest) (*GetStepStatusResponse, error)
	StreamEvents(*StreamEventsRequest, grpc.ServerStreamingServer[Event]) error
	mustEmbedUnimplementedStepServiceServer()
}

// UnimplementedStepServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedStepServiceServer struct{}

func (UnimplementedStepServiceServer) PushStep(context.Context, *PushStepRequest) (*PushStepResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PushStep not implemented")
}
func (UnimplementedStepServiceServer) CancelStep(context.Context, *CancelStepRequest) (*CancelStepResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelStep not implemented")
}
func (UnimplementedStepServiceServer) GetStepStatus(context.Context, *GetStepStatusRequest) (*GetStepStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStepStatus not implemented")
}
func (UnimplementedStepServiceServer) StreamEvents(*StreamEventsRequest, grpc.ServerStreamingServer[Event]) error {
	return status.Errorf(codes.Unimplemented, "method StreamEvents not implemented")
}
func (UnimplementedStepServiceServer) mustEmbedUnimplementedStepServiceServer() {}
func (UnimplementedStepServiceServer) testEmbeddedByValue()                     {}

// UnsafeStepServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StepServiceServer will
// result in compilation errors.
type UnsafeStepServiceServer interface {
	mustEmbedUnimplementedStepServiceServer()
}

func RegisterStepServiceServer(s grpc.ServiceRegistrar, srv StepServiceServer) {
	// If the following call pancis, it indicates UnimplementedStepServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&StepService_ServiceDesc, srv)
}

func _StepService_PushStep_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushStepRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StepServiceServer).PushStep(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StepService_PushStep_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StepServiceServer).PushStep(ctx, req.(*PushStepRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StepService_CancelStep_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelStepRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StepServiceServer).CancelStep(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StepService_CancelStep_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StepServiceServer).CancelStep(ctx, req.(*CancelStepRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StepService_GetStepStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStepStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StepServiceServer).GetStepStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StepService_GetStepStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StepServiceServer).GetStepStatus(ctx, req.(*GetStepStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StepService_StreamEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamEventsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StepServiceServer).StreamEvents(m, &grpc.GenericServerStream[StreamEventsRequest, Event]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type StepService_StreamEventsServer = grpc.ServerStreamingServer[Event]

// StepService_ServiceDesc is the grpc.ServiceDesc for StepService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StepService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "owaspchecker.broker.StepService",
	HandlerType: (*StepServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PushStep",
			Handler:    _StepService_PushStep_Handler,
		},
		{
			MethodName: "CancelStep",
			Handler:    _StepService_CancelStep_Handler,
		},
		{
			MethodName: "GetStepStatus",
			Handler:    _StepService_GetStepStatus_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamEvents",
			Handler:       _StepService_StreamEvents_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "broker.proto",
}

const (
	ArtifactService_PushArtifact_FullMethodName  = "/owaspchecker.broker.ArtifactService/PushArtifact"
	ArtifactService_GetArtifact_FullMethodName   = "/owaspchecker.broker.ArtifactService/GetArtifact"
	ArtifactService_ListArtifacts_FullMethodName = "/owaspchecker.broker.ArtifactService/ListArtifacts"
)

// ArtifactServiceClient is the client API for ArtifactService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Artifact management service
type ArtifactServiceClient interface {
	PushArtifact(ctx context.Context, in *PushArtifactRequest, opts ...grpc.CallOption) (*PushArtifactResponse, error)
	GetArtifact(ctx context.Context, in *GetArtifactRequest, opts ...grpc.CallOption) (*GetArtifactResponse, error)
	ListArtifacts(ctx context.Context, in *ListArtifactsRequest, opts ...grpc.CallOption) (*ListArtifactsResponse, error)
}

type artifactServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewArtifactServiceClient(cc grpc.ClientConnInterface) ArtifactServiceClient {
	return &artifactServiceClient{cc}
}

func (c *artifactServiceClient) PushArtifact(ctx context.Context, in *PushArtifactRequest, opts ...grpc.CallOption) (*PushArtifactResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PushArtifactResponse)
	err := c.cc.Invoke(ctx, ArtifactService_PushArtifact_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *artifactServiceClient) GetArtifact(ctx context.Context, in *GetArtifactRequest, opts ...grpc.CallOption) (*GetArtifactResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetArtifactResponse)
	err := c.cc.Invoke(ctx, ArtifactService_GetArtifact_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *artifactServiceClient) ListArtifacts(ctx context.Context, in *ListArtifactsRequest, opts ...grpc.CallOption) (*ListArtifactsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListArtifactsResponse)
	err := c.cc.Invoke(ctx, ArtifactService_ListArtifacts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ArtifactServiceServer is the server API for ArtifactService service.
// All implementations must embed UnimplementedArtifactServiceServer
// for forward compatibility.
//
// Artifact management service
type ArtifactServiceServer interface {
	PushArtifact(context.Context, *PushArtifactRequest) (*PushArtifactResponse, error)
	GetArtifact(context.Context, *GetArtifactRequest) (*GetArtifactResponse, error)
	ListArtifacts(context.Context, *ListArtifactsRequest) (*ListArtifactsResponse, error)
	mustEmbedUnimplementedArtifactServiceServer()
}

// UnimplementedArtifactServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedArtifactServiceServer struct{}

func (UnimplementedArtifactServiceServer) PushArtifact(context.Context, *PushArtifactRequest) (*PushArtifactResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PushArtifact not implemented")
}
func (UnimplementedArtifactServiceServer) GetArtifact(context.Context, *GetArtifactRequest) (*GetArtifactResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetArtifact not implemented")
}
func (UnimplementedArtifactServiceServer) ListArtifacts(context.Context, *ListArtifactsRequest) (*ListArtifactsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListArtifacts not implemented")
}
func (UnimplementedArtifactServiceServer) mustEmbedUnimplementedArtifactServiceServer() {}
func (UnimplementedArtifactServiceServer) testEmbeddedByValue()                         {}

// UnsafeArtifactServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ArtifactServiceServer will
// result in compilation errors.
type UnsafeArtifactServiceServer interface {
	mustEmbedUnimplementedArtifactServiceServer()
}

func RegisterArtifactServiceServer(s grpc.ServiceRegistrar, srv ArtifactServiceServer) {
	// If the following call pancis, it indicates UnimplementedArtifactServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ArtifactService_ServiceDesc, srv)
}

func _ArtifactService_PushArtifact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushArtifactRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArtifactServiceServer).PushArtifact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ArtifactService_PushArtifact_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArtifactServiceServer).PushArtifact(ctx, req.(*PushArtifactRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArtifactService_GetArtifact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetArtifactRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArtifactServiceServer).GetArtifact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ArtifactService_GetArtifact_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArtifactServiceServer).GetArtifact(ctx, req.(*GetArtifactRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArtifactService_ListArtifacts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListArtifactsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArtifactServiceServer).ListArtifacts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ArtifactService_ListArtifacts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArtifactServiceServer).ListArtifacts(ctx, req.(*ListArtifactsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ArtifactService_ServiceDesc is the grpc.ServiceDesc for ArtifactService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ArtifactService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "owaspchecker.broker.ArtifactService",
	HandlerType: (*ArtifactServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PushArtifact",
			Handler:    _ArtifactService_PushArtifact_Handler,
		},
		{
			MethodName: "GetArtifact",
			Handler:    _ArtifactService_GetArtifact_Handler,
		},
		{
			MethodName: "ListArtifacts",
			Handler:    _ArtifactService_ListArtifacts_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "broker.proto",
}
